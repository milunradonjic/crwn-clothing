{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _includes = _interopRequireDefault(require(\"lodash/includes\"));\n\nvar _repeat = _interopRequireDefault(require(\"lodash/repeat\"));\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _defaults = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction gatherNodeParts(node, parts) {\n  if (t.isModuleDeclaration(node)) {\n    if (node.source) {\n      gatherNodeParts(node.source, parts);\n    } else if (node.specifiers && node.specifiers.length) {\n      for (const specifier of node.specifiers) {\n        gatherNodeParts(specifier, parts);\n      }\n    } else if (node.declaration) {\n      gatherNodeParts(node.declaration, parts);\n    }\n  } else if (t.isModuleSpecifier(node)) {\n    gatherNodeParts(node.local, parts);\n  } else if (t.isMemberExpression(node)) {\n    gatherNodeParts(node.object, parts);\n    gatherNodeParts(node.property, parts);\n  } else if (t.isIdentifier(node)) {\n    parts.push(node.name);\n  } else if (t.isLiteral(node)) {\n    parts.push(node.value);\n  } else if (t.isCallExpression(node)) {\n    gatherNodeParts(node.callee, parts);\n  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {\n    for (const prop of node.properties) {\n      gatherNodeParts(prop.key || prop.argument, parts);\n    }\n  } else if (t.isPrivateName(node)) {\n    gatherNodeParts(node.id, parts);\n  } else if (t.isThisExpression(node)) {\n    parts.push(\"this\");\n  } else if (t.isSuper(node)) {\n    parts.push(\"super\");\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if (cached && cached.path === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent && parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 0;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(parent, defaultName) {\n    let node = parent;\n\n    if (t.isAssignmentExpression(parent)) {\n      node = parent.left;\n    } else if (t.isVariableDeclarator(parent)) {\n      node = parent.id;\n    } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {\n      node = node.key;\n    }\n\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(parent, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(parent, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = (0, _repeat.default)(\"-\", 60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        parent.references[name] = true;\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    let scope = this;\n\n    do {\n      if (scope.references[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isClassMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.references) this.crawl();\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isLoop()) {\n      for (const key of t.FOR_INIT_KEYS) {\n        const node = path.get(key);\n        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);\n      }\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n    }\n\n    if (path.isClassExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path);\n      }\n    }\n\n    if (path.isFunction()) {\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    if (path.isCatchClause()) {\n      this.registerBinding(\"let\", path);\n    }\n\n    const parent = this.getProgramParent();\n    if (parent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n      let programParent;\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent = programParent || path.scope.getProgramParent();\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        ref.scope.getProgramParent().addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      (0, _defaults.default)(ids, scope.bindings);\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (const kind of arguments) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        if (previousPath && previousPath.isPattern() && previousPath.parentPath.isFunction() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    const info = this.getBinding(name);\n    return info && info.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding && binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.globals, name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.contextVariables, name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    return this.parent && this.parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n    }\n\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"sources":["/home/miso/Documents/Learning_Projects/Complete React Developer in 2020/crwn-clothing/node_modules/@babel/traverse/lib/scope/index.js"],"names":["Object","defineProperty","exports","value","default","_includes","_interopRequireDefault","require","_repeat","_renamer","_index","_defaults","_binding","_globals","t","_interopRequireWildcard","_cache","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","gatherNodeParts","node","parts","isModuleDeclaration","source","specifiers","length","specifier","declaration","isModuleSpecifier","local","isMemberExpression","object","property","isIdentifier","push","name","isLiteral","isCallExpression","callee","isObjectExpression","isObjectPattern","prop","properties","argument","isPrivateName","id","isThisExpression","isSuper","collectorVisitor","For","path","FOR_INIT_KEYS","declar","isVar","parentScope","scope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","isDeclaration","parent","registerDeclaration","ReferencedIdentifier","state","references","ForXStatement","left","isPattern","constantViolations","ExportDeclaration","exit","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","isVariableDeclaration","decl","declarations","keys","getBindingIdentifiers","LabeledStatement","addGlobal","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","Block","paths","bodyPath","uid","Scope","constructor","cached","block","labels","Map","findParent","p","isScope","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","uids","generateUidBasedOnNode","defaultName","isAssignmentExpression","isVariableDeclarator","isObjectProperty","isObjectMethod","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","_renameFromMap","map","dump","sep","console","log","type","violations","toArray","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","registerLabel","label","isLabeledStatement","isImportDeclaration","buildUndefinedNode","unaryExpression","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","globals","hasUid","isPure","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elem","elements","isClassMethod","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expression","expressions","isPureish","setData","val","data","getData","removeData","init","crawl","create","isLoop","isFunctionExpression","NOT_LOCAL_BINDING","isClassExpression","isFunction","params","param","isCatchClause","crawling","programParent","ref","isBlockStatement","isProgram","isSwitchStatement","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","variableDeclaration","unshiftContainer","declarator","variableDeclarator","pop","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","arguments","bindingIdentifierEquals","getBindingIdentifier","previousPath","parentPath","info","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","contextVariables","moveBindingTo","removeOwnBinding","removeBinding","builtin"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _includes = _interopRequireDefault(require(\"lodash/includes\"));\n\nvar _repeat = _interopRequireDefault(require(\"lodash/repeat\"));\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _defaults = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  if (t.isModuleDeclaration(node)) {\n    if (node.source) {\n      gatherNodeParts(node.source, parts);\n    } else if (node.specifiers && node.specifiers.length) {\n      for (const specifier of node.specifiers) {\n        gatherNodeParts(specifier, parts);\n      }\n    } else if (node.declaration) {\n      gatherNodeParts(node.declaration, parts);\n    }\n  } else if (t.isModuleSpecifier(node)) {\n    gatherNodeParts(node.local, parts);\n  } else if (t.isMemberExpression(node)) {\n    gatherNodeParts(node.object, parts);\n    gatherNodeParts(node.property, parts);\n  } else if (t.isIdentifier(node)) {\n    parts.push(node.name);\n  } else if (t.isLiteral(node)) {\n    parts.push(node.value);\n  } else if (t.isCallExpression(node)) {\n    gatherNodeParts(node.callee, parts);\n  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {\n    for (const prop of node.properties) {\n      gatherNodeParts(prop.key || prop.argument, parts);\n    }\n  } else if (t.isPrivateName(node)) {\n    gatherNodeParts(node.id, parts);\n  } else if (t.isThisExpression(node)) {\n    parts.push(\"this\");\n  } else if (t.isSuper(node)) {\n    parts.push(\"super\");\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if (cached && cached.path === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent && parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 0;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(parent, defaultName) {\n    let node = parent;\n\n    if (t.isAssignmentExpression(parent)) {\n      node = parent.left;\n    } else if (t.isVariableDeclarator(parent)) {\n      node = parent.id;\n    } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {\n      node = node.key;\n    }\n\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(parent, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(parent, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = (0, _repeat.default)(\"-\", 60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        parent.references[name] = true;\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    let scope = this;\n\n    do {\n      if (scope.references[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isClassMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.references) this.crawl();\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isLoop()) {\n      for (const key of t.FOR_INIT_KEYS) {\n        const node = path.get(key);\n        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);\n      }\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n    }\n\n    if (path.isClassExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path);\n      }\n    }\n\n    if (path.isFunction()) {\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    if (path.isCatchClause()) {\n      this.registerBinding(\"let\", path);\n    }\n\n    const parent = this.getProgramParent();\n    if (parent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n      let programParent;\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent = programParent || path.scope.getProgramParent();\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        ref.scope.getProgramParent().addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      (0, _defaults.default)(ids, scope.bindings);\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (const kind of arguments) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        if (previousPath && previousPath.isPattern() && previousPath.parentPath.isFunction() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    const info = this.getBinding(name);\n    return info && info.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding && binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.globals, name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.contextVariables, name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    return this.parent && this.parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n    }\n\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];"]},"metadata":{},"sourceType":"script"}