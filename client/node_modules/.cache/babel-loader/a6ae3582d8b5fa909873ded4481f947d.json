{"ast":null,"code":"'use strict';\n\nconst t = require('@babel/types');\n\nconst hash = require('string-hash');\n\nconst path = require('path');\n/**\n * Basic React.Fragment check\n * We can improve it by checking import aliases if needs\n */\n\n\nconst isReactFragment = node => {\n  if (!node) return false;\n\n  if (t.isJSXFragment(node)) {\n    return true;\n  }\n\n  const [element] = node.arguments || [];\n\n  if (t.isIdentifier(element)) {\n    return element.name === 'Fragment';\n  }\n\n  if (t.isMemberExpression(element)) {\n    return element.object.name === 'React' && element.property.name === 'Fragment';\n  }\n\n  return false;\n};\n\nconst isReactElement = node => {\n  if (t.isJSXElement(node)) {\n    return true;\n  }\n\n  const {\n    callee\n  } = node;\n  if (!t.isMemberExpression(callee)) return false;\n  const {\n    object,\n    property\n  } = callee;\n  return object.name === 'React' && property.name === 'createElement';\n};\n\nconst isElement = node => node && isReactElement(node) && !isReactFragment(node);\n\nconst isReturned = p => {\n  const {\n    parent\n  } = p;\n\n  if (t.isCallExpression(parent) || t.isConditionalExpression(parent) || t.isSequenceExpression(parent) || t.isLogicalExpression(parent)) {\n    return isReturned(p.parentPath);\n  }\n\n  return t.isReturnStatement(parent) || t.isArrowFunctionExpression(parent);\n};\n\nconst projectPath = process.cwd().toLowerCase();\n\nconst getNode = p => {\n  const {\n    parent\n  } = p;\n\n  if (isReactFragment(parent)) {\n    return getNode(p.parentPath);\n  }\n\n  if (!isReturned(p)) return null;\n  let isComponent = false;\n  let componentNode = null;\n  let currentPath = p;\n  let node;\n  let parentPath;\n\n  do {\n    ({\n      node,\n      parentPath\n    } = currentPath);\n    if (parentPath && isElement(parentPath.node)) break;\n    isComponent = isComponent || t.isArrowFunctionExpression(node) || t.isFunctionExpression(node) || t.isClassMethod(node) || t.isObjectMethod(node) || t.isFunctionDeclaration(node);\n\n    if (!componentNode && isComponent) {\n      componentNode = node;\n    }\n\n    switch (currentPath.type) {\n      case 'VariableDeclaration':\n      case 'ClassDeclaration':\n      case 'ExportDefaultDeclaration':\n      case 'ExportNamedDeclaration':\n      case 'FunctionDeclaration':\n        {\n          if (!componentNode) break;\n          return {\n            rootPath: currentPath,\n            componentNode\n          };\n        }\n    }\n\n    currentPath = parentPath;\n  } while (currentPath);\n\n  return null;\n};\n\nconst getName = ({\n  rootPath\n}) => {\n  if (rootPath.type === 'ExportDefaultDeclaration' || rootPath.parent.type === 'ExportDefaultDeclaration') {\n    const names = ['default'];\n\n    if (rootPath.node && rootPath.node.id && rootPath.node.id.name) {\n      names.push(rootPath.node.id.name);\n    }\n\n    return names;\n  }\n\n  if (rootPath.type === 'VariableDeclaration') {\n    const [declarator] = rootPath.node.declarations;\n    return [declarator.id.name];\n  }\n\n  return [rootPath.node.id.name];\n};\n\nconst getId = (filename, name) => hash(`${path.relative(projectPath, filename.toLowerCase())}:${name}`.split(path.sep).join('/')).toString(16);\n\nconst buildComment = hashmap => `__reselector__start__::${JSON.stringify(hashmap)}::__reselector__end__`;\n\nconst getHashmapFromComment = content => {\n  const [, result = ''] = content.match(/__reselector__start__::(.*?)::__reselector__end__/) || [];\n  if (result) return JSON.parse(result);\n  return '';\n};\n\nmodule.exports = {\n  getNode,\n  getName,\n  getId,\n  isElement,\n  isReactFragment,\n  isReactElement,\n  buildComment,\n  getHashmapFromComment\n};","map":{"version":3,"sources":["/home/miso/Documents/Learning_Projects/Complete React Developer in 2020/crwn-clothing/node_modules/reselector/utils.js"],"names":["t","require","hash","path","isReactFragment","node","isJSXFragment","element","arguments","isIdentifier","name","isMemberExpression","object","property","isReactElement","isJSXElement","callee","isElement","isReturned","p","parent","isCallExpression","isConditionalExpression","isSequenceExpression","isLogicalExpression","parentPath","isReturnStatement","isArrowFunctionExpression","projectPath","process","cwd","toLowerCase","getNode","isComponent","componentNode","currentPath","isFunctionExpression","isClassMethod","isObjectMethod","isFunctionDeclaration","type","rootPath","getName","names","id","push","declarator","declarations","getId","filename","relative","split","sep","join","toString","buildComment","hashmap","JSON","stringify","getHashmapFromComment","content","result","match","parse","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst t = require('@babel/types');\n\nconst hash = require('string-hash');\n\nconst path = require('path');\n/**\n * Basic React.Fragment check\n * We can improve it by checking import aliases if needs\n */\n\n\nconst isReactFragment = node => {\n  if (!node) return false;\n\n  if (t.isJSXFragment(node)) {\n    return true;\n  }\n\n  const [element] = node.arguments || [];\n\n  if (t.isIdentifier(element)) {\n    return element.name === 'Fragment';\n  }\n\n  if (t.isMemberExpression(element)) {\n    return element.object.name === 'React' && element.property.name === 'Fragment';\n  }\n\n  return false;\n};\n\nconst isReactElement = node => {\n  if (t.isJSXElement(node)) {\n    return true;\n  }\n\n  const {\n    callee\n  } = node;\n  if (!t.isMemberExpression(callee)) return false;\n  const {\n    object,\n    property\n  } = callee;\n  return object.name === 'React' && property.name === 'createElement';\n};\n\nconst isElement = node => node && isReactElement(node) && !isReactFragment(node);\n\nconst isReturned = p => {\n  const {\n    parent\n  } = p;\n\n  if (t.isCallExpression(parent) || t.isConditionalExpression(parent) || t.isSequenceExpression(parent) || t.isLogicalExpression(parent)) {\n    return isReturned(p.parentPath);\n  }\n\n  return t.isReturnStatement(parent) || t.isArrowFunctionExpression(parent);\n};\n\nconst projectPath = process.cwd().toLowerCase();\n\nconst getNode = p => {\n  const {\n    parent\n  } = p;\n\n  if (isReactFragment(parent)) {\n    return getNode(p.parentPath);\n  }\n\n  if (!isReturned(p)) return null;\n  let isComponent = false;\n  let componentNode = null;\n  let currentPath = p;\n  let node;\n  let parentPath;\n\n  do {\n    ({\n      node,\n      parentPath\n    } = currentPath);\n    if (parentPath && isElement(parentPath.node)) break;\n    isComponent = isComponent || t.isArrowFunctionExpression(node) || t.isFunctionExpression(node) || t.isClassMethod(node) || t.isObjectMethod(node) || t.isFunctionDeclaration(node);\n\n    if (!componentNode && isComponent) {\n      componentNode = node;\n    }\n\n    switch (currentPath.type) {\n      case 'VariableDeclaration':\n      case 'ClassDeclaration':\n      case 'ExportDefaultDeclaration':\n      case 'ExportNamedDeclaration':\n      case 'FunctionDeclaration':\n        {\n          if (!componentNode) break;\n          return {\n            rootPath: currentPath,\n            componentNode\n          };\n        }\n    }\n\n    currentPath = parentPath;\n  } while (currentPath);\n\n  return null;\n};\n\nconst getName = ({\n  rootPath\n}) => {\n  if (rootPath.type === 'ExportDefaultDeclaration' || rootPath.parent.type === 'ExportDefaultDeclaration') {\n    const names = ['default'];\n\n    if (rootPath.node && rootPath.node.id && rootPath.node.id.name) {\n      names.push(rootPath.node.id.name);\n    }\n\n    return names;\n  }\n\n  if (rootPath.type === 'VariableDeclaration') {\n    const [declarator] = rootPath.node.declarations;\n    return [declarator.id.name];\n  }\n\n  return [rootPath.node.id.name];\n};\n\nconst getId = (filename, name) => hash(`${path.relative(projectPath, filename.toLowerCase())}:${name}`.split(path.sep).join('/')).toString(16);\n\nconst buildComment = hashmap => `__reselector__start__::${JSON.stringify(hashmap)}::__reselector__end__`;\n\nconst getHashmapFromComment = content => {\n  const [, result = ''] = content.match(/__reselector__start__::(.*?)::__reselector__end__/) || [];\n  if (result) return JSON.parse(result);\n  return '';\n};\n\nmodule.exports = {\n  getNode,\n  getName,\n  getId,\n  isElement,\n  isReactFragment,\n  isReactElement,\n  buildComment,\n  getHashmapFromComment\n};"]},"metadata":{},"sourceType":"script"}